# this和闭包

### this

- 默认绑定规则，全局里，this指向window。但是开启严格模式时，会消除默认绑定。
- 隐式绑定，当一个函数被赋值为一个对象的属性时，该对象就成为函数运行的宿主。换句话说，函数中的 this将自动指向该对象。这是JS中的第二条规则，名为隐式绑定。
- 显示绑定，bind，call&apply，手动指定this的指向
- new绑定，在构造函数上使用new的时候，this总是指向新创建的对象。
- 箭头函数，箭头函数内没有this属性，它的this属性是外层的this的指向。

### 执行上下文

函数每次执行，都会生成一个会创建一个称为执行上下文的内部对象（AO 对象，可理解为函数作用域），这个 AO 对象会保存这个函数中所有的变量值和该函数内部定义的函数的引用。函数每次执行时对应的执行上下文都是独一无二的，**正常情况下函数执行完毕执行上下文就会被销毁**。

在函数定义的时候，他还获得 [[scope]]。这个是里面包含该函数的**作用域链**，初始值为引用着上一层作用域链里面所有的作用域，后面执行的时候还会将 AO 对象添加进去 。作用域链就是执行上下文对象的集合，这个集合是链条状的。

正常情况函数每次执行后 AO 对象都被销毁，且每次执行时都是生成新的 AO 对象。我们得出这个结论： 只要是这个函数每次调用的结果不一样，那么这个函数内部一定是使用了函数外部的变量。

### 闭包

闭包：一个能够记住其环境变量的函数。为此，内部函数必须是一个封闭(外部)函数的返回值。

闭包的原理，就是把闭包函数的作用域链保存了下来。

作用：

- 提供私有的全局变量

  ```javascript
  var Person = (function() {
    var person = {
      name: "",
      age: 0
    };
  
    function setName(personName) {
      person.name = personName;
    }
  
    function setAge(personAge) {
      person.age = personAge;
    }
  })();
  ```

  从外部咱们无法访问`person.name`或`person.age`。咱们也不能调用`setName`或`setAge`。

- 在函数调用之间保存状态

全局变量很容易引发bug，咱们应该尽可能地避免它们。有时全局变量是有用的，需要格外小心使用，因为JS引擎可以自由地创建全局变量。

这些年来出现了许多模式来管理全局变量，模块模式就是其中之一。模块模式建立在闭包上，这是JS的固有特性。JS 中的闭包是一种能够“记住”其变量环境的函数，即使在后续函数调用之间也是如此。当咱们从另一个函数返回一个函数时，会创建一个闭包，这个模式也称为**“工厂函数**”。

#### 运用

- 模块化 - nodejs模块化原理

```javascript
(funciton(exports, require, module, __filename, __dirname) {
    /* 自己写的代码  */
})();
```

- 柯里化
- 节流防抖
- bind的实现

### 参考

[搞懂闭包-alloyteam](http://www.alloyteam.com/2019/07/closure/)