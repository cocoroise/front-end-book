# js垃圾回收机制

### 🕊介绍

像C语言这样的底层语言一般都有底层的内存管理接口，比如 `malloc()`和`free()`。相反，JavaScript是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时''**自动''**释放。 释放的过程称为垃圾回收。这个“自动”是混乱的根源，并让JavaScript（和其他高级语言）开发者错误的感觉他们可以不关心内存管理。

### 🐇内存生命周期

1. 分配你所需要的内存
2. 使用分配到的内存（读、写）
3. 不需要时将其释放或归还

### 🦢垃圾回收机制

1. #### 引用计数

   在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。

   引用计数算法把“对象是否不再需要”简化定义为“**对象有没有其他对象引用到它**”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。引用计数的本质是 **跟踪记录每个值被引用的次数**。

   但是，它的限制就是无法处理循环引用。

   ```js
   function f(){
     var o = {};
     var o2 = {};
     o.a = o2; // o 引用 o2
     o2.a = o; // o2 引用 o
   
     return "azerty";
   }
   
   f();
   ```

   

2. #### 标记-清除

   这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。

   这个算法假定设置一个叫做**根（root）**的对象（在Javascript里，根是**全局对象**）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有**可以获得的对象**和收集**所有不能获得的对象**。

   标记清除采用的详细收集策略为：

   - JavaScript中的垃圾收集器运行时会给**存储在内存中的所有变量**都加上标记；
   - 然后去掉环境中的变量以及被环境中的变量引用的变量的标记；
   - 此后，再被加上标记的变量被视为准备删除的变量；
   - 最后，垃圾收集器完成内存清除，销毁那些带标记的值并回收其占用的内存空间。

   这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。

   从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。

### 🐈垃圾回收机制的性能问题

垃圾收集器是周期运行的，确定 **垃圾收集的时间间隔** 是个重要的问题。

IE7之前的垃圾收集器是根据**内存分配量**运行的，即 256 个变量、4096 个对象(数组)字面量或 64 KB 的字符串。达到这些临界值的任何一个，垃圾收集器就会运行。所以就导致如果一个脚本含有很多变量，在整个生命周期中一直保有前面临界值大小的变量，就会频繁触发垃圾回收，会存在严重的性能问题。

IE7 重写了垃圾收集例程。新的工作方式为：触发垃圾收集的变量分配、字面量和数组元素的临界值被调整为 **动态修正**。初始值与之前版本相同，但如果垃圾收集例程回收的**内存低于 15%**，则临界值加倍。若回收内存分配量超过 85%，则临界值重置回默认值。

### 🐩V8 引擎的垃圾回收机制

V8是有内存限制的，因为它最开始是为浏览器设计的，不太可能遇到大量内存的使用场景。关键原因还是垃圾回收所导致的线程暂停执行的时间过长。根据官方说法，以1.5G内存为例，V8一次小的垃圾回收需要50ms，而一次非增量的，即全量的垃圾回收更需要一秒。这显然是不可接受的。因此V8限制了内存使用的大小，但是Node.js是可以通过配置修改的，更好的做法是使用`Buffer`对象，因为`Buffer`的内存是底层C++分配的，不占用JS内存，所以他也就不受V8限制。

V8 中的垃圾回收主要使用的是 **分代回收** (Generational collection)机制。

V8 引擎将保存对象的 **堆** (heap) 进行了分代:

- 对象最初会被分在 **新生区**(New Space) (1~8M)，新生区的内存分配只需要保有一个指向内存区的指针，不断根据内存大小进行递增，当指针达到新生区的末尾，会有一次垃圾回收清理(小周期)，清理掉新生区中不再活跃的死对象。
- 对于**超过 2 个小周期**的对象，则需要将其移动至 **老生区**(Old Space)。老生区在 标记-清除 或 标记-紧缩 的过程(大周期) 中进行回收。

大周期进行的并不频繁。一次大周期通常是在移动足够多的对象至老生区后才会发生。

#### 垃圾清理

由于垃圾清理发生的比较频繁，清理的过程必须很快。V8 中的清理过程使用的是 **Scavenge** 算法，按照 经典的 **Cheney** 算法实现的。Scavenge 算法的主要过程是：

- 新生区被分为两个等大小的子区(semi-spaces)：to-space 和 from-space；
- 大多数的内存分配都是在 to-space 发生 (某些特定对象是在老生区)；
- 当 to-space 耗尽时，交换 to-space 和 from-space, 此时所有的对象都在 from-space；
- 然后将 from-space 中活跃的对象复制到 to-space 或者老生区中;
- 这些对象被直接压到 to-space，提升了 Cache 的内存局部性，可使内存分配简洁快速。



### 🐏参考

[内存管理 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)

[JavaScript 垃圾回收机制](https://juejin.im/post/5cf4d12ee51d45775746b8ea)

[JavaScript的内存管理](https://juejin.im/post/5e2155cee51d4552455a8878)